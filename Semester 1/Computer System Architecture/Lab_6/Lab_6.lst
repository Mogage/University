     1                                  bits 32 ; assembling for the 32 bits architecture
     2                                  
     3                                  ; declare the EntryPoint (a label defining the very first instruction of the program)
     4                                  global start        
     5                                  
     6                                  ; declare external functions needed by our program
     7                                  extern exit, printf            ; tell nasm that exit exists even if we won't be defining it
     8                                  import exit msvcrt.dll    ; exit is a function that ends the calling process. It is defined in msvcrt.dll
     9                                  import printf msvcrt.dll    ; exit is a function that ends the calling process. It is defined in msvcrt.dll
    10                                                            ; msvcrt.dll contains exit, printf and all the other important C-runtime specific functions
    11                                  
    12                                  ; our data is declared here (the variables needed by our program)
    13                                  segment data use32 class=data
    14                                      
    15                                      ; Cerinta:
    16                                      ;   Dandu-se un sir de cuvinte, sa se calculeze cel mai lung subsir de cuvinte ordonate crescator din acest sir.
    17                                      
    18 00000000 500251025202                sir: dw 250h, 251h, 252h   ; Sirul de cuvinte din care se cauta 
    19                                      
    20                                      number_elements equ ($ - sir) / 2   ; Numarul de cuvinte din sir
    21                                      
    22 00000006 0000<rept>                  rez times number_elements dw 0      ; Sirul in care urmeaza sa fie pus rez
    23                                      
    24 0000000C 00                          first_pos db 0      ; Pozitia de pe care incepe subsirul
    25 0000000D 00                          second_pos db 0     ; Pozitia pe care se termina subsirul
    26 0000000E 01                          aux_length db 1     ; Var auxiliara pentru calcularea subsirului de lungime maxima
    27 0000000F 01                          max_length db 1     ; Lungimea maxima a subsirului
    28                                      
    29 00000010 25782000                    format db "%x ", 0  ; Format pentru afisarea nr in baza 16
    30                                      
    31                                  ; our code starts here
    32                                  segment code use32 class=code
    33                                      start:
    34 00000000 31C0                            xor EAX, EAX
    35 00000002 31DB                            xor EBX, EBX
    36 00000004 31C9                            xor ECX, ECX
    37 00000006 31D2                            xor EDX, EDX
    38                                          
    39 00000008 BE[00000000]                    mov ESI, sir    ; ESI = adresa primului cuvant
    40 0000000D BF[00000000]                    mov EDI, sir
    41 00000012 83C702                          add EDI, 2      ; EDI = adresa celui al doilea cuvant
    42 00000015 BB01000000                      mov EBX, 1      ; Prin EBX vom memora pozitia cuvantului actual din sir
    43 0000001A B902000000                      mov ECX, number_elements - 1    ; Vom parcurge sirul intr-o bucla loop cu number_elements - 1 iteratii
    44                                          
    45                                      repeta:
    46 0000001F 66A7                            cmpsw                       ; Comparam cuvintele de pe pozitii consecutive
    47 00000021 7708                            ja descrescator             ; Daca sir[BL - 1] > sir[BL] inseamna ca nu e crescator si sarim
    48                                          
    49 00000023 FE05[0E000000]                  inc byte [aux_length]       ; Altfel crestem valoare lungimii auxiliare cu 1
    50 00000029 EB07                            jmp crescator               ; si sarim peste operatia din cazul sir[i] > sir[i + 1]
    51                                      descrescator:                   ; Daca sir[BL - 1] > sir[BL] putem zice ca la pasul curent lungimea auxiliara a subsirului
    52 0000002B C605[0E000000]01                mov byte [aux_length], 1    ; este 1
    53                                      crescator:
    54 00000032 A0[0E000000]                    mov AL, [aux_length]        ; AL = aux_length
    55 00000037 8A25[0F000000]                  mov AH, [max_length]        ; AH = max_length
    56 0000003D 38E0                            cmp AL, AH                  ; Verificam daca s-a gasit o lungime auxiliara mai mare decat cea maxima
    57 0000003F 761F                            jbe continua                ; Daca aux_length <= max_length inseamna ca nu s-a gasit un subsir cu lungime 
    58                                                                      ; mai mare si sasim 
    59 00000041 881D[0D000000]                  mov byte [second_pos], BL   ; second_pos = BL
    60                                          
    61                                          ; first_pos = BL - aux_length + 1
    62 00000047 88D8                            mov AL, BL                  ; AL = BL
    63 00000049 2A05[0E000000]                  sub AL, byte [aux_length]   ; AL = AL - aux_length = BL - aux_length
    64 0000004F FEC0                            inc AL                      ; AL = AL + 1 = BL - aux_length + 1
    65 00000051 A2[0C000000]                    mov byte [first_pos], AL    ; first_pos = AL
    66                                          
    67                                          ; max_length - aux_length
    68 00000056 A0[0E000000]                    mov AL, byte [aux_length]
    69 0000005B A2[0F000000]                    mov byte [max_length], AL
    70                                          
    71                                      continua:
    72 00000060 6643                            inc BX                      ; BX = BX + 1 | Trecem la urmatorul element
    73                                          
    74 00000062 E2BB                            loop repeta                 ; Daca mai sunt cuvinte de parcus, se reia ciclul
    75                                          
    76 00000064 8A1D[0F000000]                  mov BL, byte [max_length]   ; Punem in BL lungimea subsirului
    77                                          
    78 0000006A 31C0                            xor EAX, EAX
    79 0000006C B002                            mov AL, 2
    80 0000006E F625[0C000000]                  mul byte [first_pos]
    81 00000074 BE[00000000]                    mov ESI, sir
    82 00000079 01C6                            add ESI, EAX
    83                                          
    84                                      afisare:
    85 0000007B 66AD                            lodsw
    86                                          
    87 0000007D 668982[06000000]                mov word [rez + EDX], AX
    88 00000084 83C202                          add EDX, 2
    89                                          
    90 00000087 50                              push EAX
    91 00000088 68[10000000]                    push format
    92 0000008D FF15[00000000]                  call [printf]
    93 00000093 83C408                          add ESP, 8
    94                                          
    95 00000096 664B                            dec BX
    96 00000098 75E1                            jnz afisare
    97                                          
    98                                          ; exit(0)
    99 0000009A 6A00                            push    dword 0      ; push the parameter for exit onto the stack
   100 0000009C FF15[00000000]                  call    [exit]       ; call exit to terminate the program
