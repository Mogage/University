     1                                  bits 32 ; assembling for the 32 bits architecture
     2                                  
     3                                  ; declare the EntryPoint (a label defining the very first instruction of the program)
     4                                  global start        
     5                                  
     6                                  ; declare external functions needed by our program
     7                                  extern exit, printf            ; tell nasm that exit exists even if we won't be defining it
     8                                  import exit msvcrt.dll    ; exit is a function that ends the calling process. It is defined in msvcrt.dll
     9                                  import printf msvcrt.dll    ; exit is a function that ends the calling process. It is defined in msvcrt.dll
    10                                                            ; msvcrt.dll contains exit, printf and all the other important C-runtime specific functions
    11                                  
    12                                  ; our data is declared here (the variables needed by our program)
    13                                  segment data use32 class=data
    14                                      
    15                                      ; S: db '+', '4', '2', 'a', '8', '4', 'X', '5'
    16 00000000 303132                      S: db '0', '1', '2'
    17                                      
    18                                      l equ $ - S
    19                                      
    20 00000003 00<rept>                    d times l db 0
    21                                      
    22                                  ; our code starts here
    23                                  segment code use32 class=code
    24                                      start:
    25 00000000 31C0                            xor     EAX, EAX    ; EAX = 0
    26 00000002 31DB                            xor     EBX, EBX    ; EBX = 0
    27 00000004 31D2                            xor     EDX, EDX    ; EDX = 0
    28                                          
    29                                          ; Cerinta:
    30                                          ;    Se da un sir de caractere S. Sa se construiasca sirul D care sa contina toate caracterele cifre din sirul S.
    31                                          ; Exemplu:
    32                                          ;   S: '+', '4', '2', 'a', '8', '4', 'X', '5'
    33                                          ;   D: '4', '2', '8', '4', '5'
    34                                          
    35 00000006 B903000000                      mov     ECX, l      ; ECX = l
    36 0000000B 31F6                            xor     ESI, ESI    ; ESI = 0
    37 0000000D 31FF                            xor     EDI, EDI    ; EDI = 0
    38                                          
    39 0000000F B330                            mov     BL, '0'  ; BL = '0', 30 in ASCII
    40 00000011 B239                            mov     DL, '9'  ; DL = '9', 39 in ASCII
    41                                          
    42 00000013 E318                            jecxz sfarsit       ; Daca lungimea sirului S e 0, adica daca ECX e 0 sare la finalul programului
    43                                          
    44                                      repeta:         ; Start instructiune repetitiva
    45                                          
    46 00000015 8A86[00000000]                  mov     AL, byte [S + ESI]  ; AL = un caracter din sirul S de pe poz ESI
    47 0000001B 46                              inc     ESI                 ; ESI = ESI + 1
    48 0000001C 38D8                            cmp     AL, BL              ; Compara caracterul curent cu '0'
    49 0000001E 7C0B                            jl continua                 ; Daca este mai mic decat '0' nu este numar si nu se adauga in D si se sare la finalul instructiunii repetitive
    50 00000020 38D0                            cmp     AL, DL              ; Compara caracterul curent cu '9'
    51 00000022 7F07                            jg continua                 ; Daca este mai mare decat '9' nu este numar si nu se adauga in D si se sare la finalul instructiunii repetitive
    52                                          
    53 00000024 8887[03000000]                  mov     byte [d + EDI], AL  ; Se adauga numarul in D
    54 0000002A 47                              inc     EDI                 ; EDI = EDI + 1
    55                                          
    56                                      continua:       ; Se continua pentru cazul in care caracterul nu e numar
    57                                      
    58 0000002B E2E8                        loop repeta     ; Continuare intructiune repetitiva
    59                                          
    60                                  
    61                                      sfarsit:        ; Terminare program
    62                                          
    63                                          ; Afisare d
    64 0000002D 68[03000000]                    push    dword d
    65 00000032 FF15[00000000]                  call    [printf]
    66 00000038 83C404                          add     esp, 4
    67                                          
    68                                          ; exit(0)
    69 0000003B 6A00                            push    dword 0      ; push the parameter for exit onto the stack
    70 0000003D FF15[00000000]                  call    [exit]       ; call exit to terminate the program
