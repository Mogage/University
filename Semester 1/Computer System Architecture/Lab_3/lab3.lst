     1                                  bits 32 ; assembling for the 32 bits architecture
     2                                  
     3                                  ; declare the EntryPoint (a label defining the very first instruction of the program)
     4                                  global start        
     5                                  
     6                                  ; declare external functions needed by our program
     7                                  extern exit               ; tell nasm that exit exists even if we won't be defining it
     8                                  import exit msvcrt.dll    ; exit is a function that ends the calling process. It is defined in msvcrt.dll
     9                                                            ; msvcrt.dll contains exit, printf and all the other important C-runtime specific functions
    10                                  
    11                                  ; our data is declared here (the variables needed by our program)
    12                                  segment data use32 class=data
    13                                      ; Adunări, scăderi: 10 (prima parte) 11 (a doua parte)    
    14                                      
    15                                      ; 10
    16                                      ; a db 2h
    17                                      ; b dw 8888h
    18                                      ; c dd 1110h
    19                                      ; d dq 0FFFFFFFFh
    20                                      
    21                                      ; 11
    22                                      ; a db 1h
    23                                      ; b dw 0FFFFh
    24                                      ; c dd 20h
    25                                      ; d dq 10000h
    26                                  
    27                                      ; Înmulțiri, împărțiri: 20 
    28                                      
    29 00000000 0300                        a dw 3h
    30 00000002 07                          b db 7h
    31 00000003 00100000                    e dd 1000h
    32 00000007 0000010000000000            x dq 10000h
    33                                      
    34                                      
    35                                  ; our code starts here
    36                                  segment code use32 class=code
    37                                      start:
    38 00000000 31C0                            xor EAX, EAX
    39 00000002 31DB                            xor EBX, EBX
    40 00000004 31C9                            xor ECX, ECX
    41 00000006 31D2                            xor EDX, EDX
    42                                          
    43                                          ; Adunări, scăderi: 10 (prima parte) 11 (a doua parte)    
    44                                          
    45                                          ; 10 - (a+d+d)-c+(b+b) = (2 + FFFF FFFF + FFFF FFFF) - 1110 + (8888 + 8888) = 2 0001 0000
    46                                          ; Spatii lasate la fiecare 4 bytes pentru o citire mai usoara
    47                                          ; CF = Carry Flag
    48                                          ; mov AL, [a] ; AL = a
    49                                          
    50                                          ; add EAX, dword [d]      ; EAX = EAX + cei 4 bytes low a lui d
    51                                          ; adc EDX, dword [d + 4]  ; EDX = EDX + cei 4 bytes high a lui d + CF
    52                                          
    53                                          ; add EAX, dword [d]      ; EBX = cei 4 bytes low a lui d
    54                                          ; adc EDX, dword [d + 4]  ; ECX = cei 4 bytes high a lui d
    55                                          
    56                                          ; ; EDX:EAX = a + d + d
    57                                          
    58                                          ; sub EAX, [c]            ; EAX = EAX - c = (a + d + d) - c
    59                                          ; sbb EDX, 0              ; EDX = EDX - CF, pentru cazul in care se imprumuta pentru scaderea lui c
    60                                  
    61                                          ; MOV BX, [b]             ; BX = b
    62                                          ; add BX, [b]             ; BX = BX + b = b + b
    63                                          ; adc CX, 0               ; CX = CX + CF, in cazul in care depasteste b + b
    64                                          
    65                                          ; push CX
    66                                          ; push BX
    67                                          ; pop EBX
    68                                          
    69                                          ; ; EBX = CX:BX = b + b
    70                                          
    71                                          ; add EAX, EBX            ; EAX = EAX + EBX = (a + d + d) - c + (b + b)
    72                                          ; adc EDX, 0              ; EDX = EDX + CF
    73                                          
    74                                          ; Rezultat este in EDX:EAX
    75                                          
    76                                          ; ------------------------------------------------------------------------------
    77                                          
    78                                          ; 11 - d-(a+b+c)-(a+a) = 1 0000 - (1 + FFFF + 20) - (1 + 1) = FFDE
    79                                          
    80                                          ; mov AL, [a]     ; AL = a
    81                                          ; cbw             ; conversie cu semn de la AL la AX
    82                                          ; cwd             ; conversie cu semn de la AX la DX:AX
    83                                          
    84                                          ; push DX 
    85                                          ; push AX
    86                                          ; pop EBX
    87                                          
    88                                          ; ; EBX = DX:AX = a
    89                                          
    90                                          ; mov AX, [b]     ; AX = b
    91                                         
    92                                          ; cwde ; conversie cu semn AX -> EAX
    93                                          
    94                                          ; add EAX, EBX    ; EAX = EAX + EBX = b + a
    95                                          
    96                                          ; cdq ; conversie cu semn de la EAX la EDX:EAX
    97                                          
    98                                          ; clc
    99                                          ; add EAX, [c]    ; EAX = EAX + c = a + b + c
   100                                          ; adc EDX, 0
   101                                          
   102                                          ; mov EBX, dword [d]          ; EBX = cei 4 bytes low din d
   103                                          ; mov ECX, dword [d + 4]      ; ECX = cei 4 bytes high din d
   104                                          
   105                                          ; ; ECX:EBX = d
   106                                          
   107                                          ; sub EBX, EAX        ; EBX = EBX - EAX 
   108                                          ; sub ECX, EDX        ; ECX = ECX - EDX
   109                                          
   110                                          ; ; ECX:EBX = d - (a + b + c)
   111                                          
   112                                          ; xor EAX, EAX        ; EAX = 0
   113                                          ; xor EDX, EDX        ; EDX = 0
   114                                          
   115                                          ; mov AL, [a]         ; AL = a
   116                                          ; cbw     ; conversie cu semn de la AL la AX
   117                                          ; add AL, [a]         ; AL = AL + a = a + a
   118                                          
   119                                          ; cwde    ; conversie cu semn de la AX la EAX
   120                                          ; cdq     ; conversie cu semn de la EAX la EDX:EAX
   121                                          
   122                                          ; sub EBX, EAX        ; EBX = EBX - EAX
   123                                          ; sbb ECX, EDX        ; ECX = ECX - EDX - CF
   124                                          
   125                                          ; ; ECX:EBX = d - (a + b + c) - (a + a)
   126                                          
   127                                          ; mov EAX, EBX        ; EAX = EBX
   128                                          ; mov EDX, ECX        ; EDX = ECX
   129                                          
   130                                          ; EDX:EAX = ECX:EBX, rezultatul fiind in EDX:EAX
   131                                          
   132                                          ; ------------------------------------------------------------------------------
   133                                          
   134                                          ; Înmulțiri, împărțiri: 20  
   135                                          
   136                                          ; 20 - x-b+8+(2*a-b)/(b*b)+e = 1 0000 - 7 + 8 + (2 * 3 - 7) / (7 * 7) + 1000 = 53A 882A
   137                                          ; Interpretare fara semn
   138                                          
   139                                          ; mov AL, [b]     ; AL = b
   140                                          ; mul AX          ; DX:AX = AX * AX = b * b
   141                                          ; mov CX, AX      ; CX = AX = b * b
   142                                          
   143                                          ; mov AX, 2       ; AX = 2
   144                                          ; mul word [a]    ; DX:AX = AX * a = 2 * a
   145                                          
   146                                          ; ; EAX = DX:AX = 2 * a
   147                                          ; push DX
   148                                          ; push AX
   149                                          ; pop EAX
   150                                  
   151                                          ; mov BL, [b]     ; BL = b
   152                                          ; sub EAX, EBX    ; EAX = EAX - EBX = 2 * a - b
   153                                          
   154                                          ; div ECX         ; EAX = EDX:EAX / ECX = (2 * a - b) / (b * b)
   155                                          ; xor EDX, EDX    ; EDX = 0, incat nu avem nevoie de rest
   156                                          
   157                                          ; add EAX, [x]        ; EAX = EAX + cei 4 bytes low din x = x + (2 * a - b) / (b * b)
   158                                          ; adc EDX, [x + 4]    ; EDX = EDX + cei 4 bytes high din x + CF
   159                                          
   160                                          ; add EAX, [e]    ; EAX = EAX + e = x + (2 * a - b) / (b * b) + e
   161                                          ; adc EDX, 0      ; EAX = EAX + 0 + CF
   162                                          
   163                                          ; ; EDX:EAX = x - b + (2 * a - b) / (b * b) + e
   164                                          ; sub EAX, EBX    ; EAX = EAX - EBX
   165                                          ; sbb EDX, 0      ; EDX = EDX - 0 - CF
   166                                          
   167                                          ; add EAX, 8      ; EAX = EAX + 8
   168                                          ; adc EDX, 0      ; EDX = EDX - 0 - CF 
   169                                          
   170                                          ; EDX:EAX = x - b + 8 + (2 * a - b) / (b * b) + e
   171                                  
   172                                          ; ------------------------------------------------------------------------------
   173                                          
   174                                          ; 20 - x-b+8+(2*a-b)/(b*b)+e = 1 0000 - 7 + 8 + (2 * 3 - 7) / (7 * 7) + 1000 = 1 1001
   175                                          ; Interpretare cu semn
   176                                          
   177 00000008 A0[02000000]                    mov AL, [b]     ; AL = b
   178 0000000D F6E8                            imul AL         ; AX = AL * AL = b * b
   179 0000000F 6689C1                          mov CX, AX      ; CX = AX = b * b
   180                                          
   181 00000012 66B80200                        mov AX, 2       ; AX = 2
   182 00000016 66F72D[00000000]                imul word [a]   ; DX:AX = 2 * a
   183                                          
   184                                          ; EAX = DX:AX = 2 * a
   185 0000001D 6652                            push DX
   186 0000001F 6650                            push AX
   187 00000021 58                              pop EAX
   188                                  
   189 00000022 8A1D[02000000]                  mov BL, [b]     ; BL = b
   190 00000028 29D8                            sub EAX, EBX    ; EAX = EAX - EBX = 2 * a - b
   191 0000002A 99                              cdq             ; conversie cu semn de la EAX la EDX:EAX
   192                                          
   193 0000002B F7F9                            idiv ECX        ; EAX = EDX:EAX / ECX = EAX = (2 * a - b) / (b * b), EDX = EDX:EAX % ECX
   194 0000002D 31D2                            xor EDX, EDX    ; EDX = 0 fiindca ne folosim doar de catul de la impartire
   195                                          
   196                                          ; EDX:EAX = x + (2 * a - b) / (b * b)
   197 0000002F 0305[07000000]                  add EAX, [x]        ; EAX = EAX + cei 4 biti low din x 
   198 00000035 1315[0B000000]                  adc EDX, [x + 4]    ; EDX = EDX + cei 4 biti high din x
   199                                          
   200                                          ; EDX:EAX = x + (2 * a - b) / (b * b) + e
   201 0000003B 0305[03000000]                  add EAX, [e]    ; EAX = EAX + e = x + (2 * a - b) / (b * b) + e
   202 00000041 83D200                          adc EDX, 0    ; EAX = EAX + 0 + CF, daca de exemplu x = FFFF FFFF iar e = 1 rezultatul din EDX:EAX trebuie sa fie 1 0000 0000
   203                                          
   204                                          ; EDX:EAX = x - b + (2 * a - b) / (b * b) + e
   205 00000044 29D8                            sub EAX, EBX    ; EAX = EAX - EBX
   206 00000046 99                              cdq             ; conversie cu semn de la EAX la EDX:EAX
   207                                          
   208 00000047 83C008                          add EAX, 8
   209 0000004A 99                              cdq             ; conversie cu semn de la EAX la EDX:EAX
   210                                          ; EDX:EAX = x - b + 8 + (2 * a - b) / (b * b) + e
   211                                      
   212                                          ; exit(0)
   213 0000004B 6A00                            push    dword 0      ; push the parameter for exit onto the stack
   214 0000004D FF15[00000000]                  call    [exit]       ; call exit to terminate the program
